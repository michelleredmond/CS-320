# CS-320
A developer should use make sure the product is id functional and secure. The environment should be secure and double down on the notifications in the environment. The program language and framework should be chosen based on the project’s needs and guidelines. The language is most important because it determines the functionality of the program. Next, the user requirements add value to the product because it incorporates the needs into a program, we need to engage in a process wherein users understand their problems, processes, goals, and preferences. Accessibility needs are important because user needs should be collected from users with diverse characteristics and abilities. Lastly, the features connect with the functions because it defines how functions are implemented. 
There are two approaches that can be taken. The first one is the Top-down approach where each system is divided into sets of subsystems and components. When the systems divide it forms a hierarchy structure. It really focuses on requirements that help to make a design responsive according to its requirements.


Project 1



As I was completing my milestones, I tried hard to use the guidelines as a guide. I tested all application functions required. These were not easy guidelines for me because writing code is still developing for me. I tested the code readability. The names of the project were a problem for me, so I changed mine. This is important because this can determine if the test will read accurately. I approached it initially not trying to have any reoccurring bugs, but I did not accomplish this in the Contact and Appointment programs. I was looking for the least number of errors because this would be an indication of testing green. If errors occur, then the test will read red as mine did. This also meant I did not have high code coverage. I tested some of my tests at least five times, but this process was frustrating. Although some of the levels were green the test was still considered a failure. However, I think my test sites could have been better without so many bugs. The main reason for the testing was to cover all paths. The Junit test is supposed to verify behaviors to ensure the performance is accurate.The best practice I used was when I tested the different pathways individually. 
The first thing I did was created the project and classes one at a time. Once I did this, I tested each requirement at a time. The system automatically noticed it was a Junit test. This also helped me change code little by little and kept the case numbers to a minimum. It also helped me prevent and identify the root cause of test case failures and you will have to debug the code. For best results, a tester should name the unit test clearly and consistently. This ensures the operations have no modification because they will remain the same. I wanted the unit test to perform one assertion at a time. This was important to me because it allowed me to notice the errors better.
I was very optimistic and positive going into each project. However, I become highly frustrated with the errors because I did not know what to do with some of them, Once fixed some errors then more errors would pop up. This made it impossible to figure out the solution and more impossible to get green. This class goes on my hardest class list. If I had to test some of my own code, I would be biased. I would know what to fix immediately, when you are dealing with or using someone else code it’s different. This becomes a game of right and wrong. When I stuck to my own personal guide in rules, I was able to get it right and get greens. This was difficult but was determined to get at least one correct.



